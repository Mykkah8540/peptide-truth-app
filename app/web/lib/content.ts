import { readFileSync, readdirSync } from "node:fs";
import path from "node:path";

export type EntityKind = "peptide" | "blend";

export type EntityListItem = {
  kind: EntityKind;
  slug: string;
  name: string;       // display name
  route?: string;     // optional precomputed route
};

export type TopicListItem = {
  slug: string;
  title: string;
  summary?: string;
};

function repoRoot(): string {
  // During Next runtime, process.cwd() will be app/web (or similar).
  // Repo root is two levels up from app/web -> repo root.
  return path.resolve(process.cwd(), "..", "..");
}

function readJson<T>(fp: string): T {
  const raw = readFileSync(fp, "utf-8");
  return JSON.parse(raw) as T;
}

function safeString(v: unknown): string {
  if (typeof v === "string") return v;
  return "";
}

function titleFromSlug(slug: string): string {
  if (!slug) return "";
  return slug
    .replace(/[-_]+/g, " ")
    .replace(/\b\w/g, (m) => m.toUpperCase());
}

/**
 * entities_v1.json is generated by your repo scripts and is the best, canonical browse source.
 * We keep this loader permissive so it doesn't explode if the index schema evolves.
 */
export function listEntities(kind: EntityKind): EntityListItem[] {
  const root = repoRoot();
  const fp = path.join(root, "content", "_index", "entities_v1.json");

  let doc: any;
  try {
    doc = readJson<any>(fp);
  } catch (e) {
    // Fallback: if entities index missing, return empty so UI doesn't crash.
    return [];
  }

  const entities: any[] =
    kind === "peptide"
      ? (Array.isArray((doc as any)?.peptides) ? (doc as any).peptides : [])
      : kind === "blend"
        ? (Array.isArray((doc as any)?.blends) ? (doc as any).blends : [])
        : (Array.isArray((doc as any)?.entities) ? (doc as any).entities : []);

  const out: EntityListItem[] = entities
    .map((e) => {
      const k = safeString(e?.kind) as EntityKind;
      const slug = safeString(e?.slug);
      const route = safeString(e?.route);
      const canonical = safeString(e?.canonical_name) || safeString(e?.name);
      const short = safeString(e?.short_name);
      const name = short || canonical || titleFromSlug(slug);

      return { kind: k, slug, name, route };
    })
    .filter((x) => x.kind === kind && !!x.slug);

  // Stable order: by name then slug
  out.sort((a, b) => (a.name.localeCompare(b.name) || a.slug.localeCompare(b.slug)));
  return out;
}

export function listPeptides(): EntityListItem[] {
  return listEntities("peptide");
}

export function listBlends(): EntityListItem[] {
  return listEntities("blend");
}

/**
 * Topics live under content/topics/pages/*.json.
 * Again we keep this permissive and filename-based so it's robust.
 */
export function listTopics(): TopicListItem[] {
  const root = repoRoot();
  const dir = path.join(root, "content", "topics", "pages");

  let files: string[] = [];
  try {
    files = readdirSync(dir).filter((f) => f.endsWith(".json"));
  } catch (e) {
    return [];
  }

  const topics: TopicListItem[] = [];
  for (const f of files) {
    const fp = path.join(dir, f);
    try {
      const doc: any = readJson<any>(fp);
      const slug = safeString(doc?.slug) || f.replace(/\.json$/, "");
      const title = safeString(doc?.title) || titleFromSlug(slug);
      const summary = safeString(doc?.summary) || safeString(doc?.description);
      topics.push({ slug, title, summary: summary || undefined });
    } catch {
      // ignore bad topic file
    }
  }

  topics.sort((a, b) => (a.title.localeCompare(b.title) || a.slug.localeCompare(b.slug)));
  return topics;
}

// --- Loaders (single entity/topic pages) ------------------------------------

export function loadPeptideBySlug(slug: string): any {
  const root = repoRoot();
  const fp = path.join(root, "content", "peptides", `${slug}.json`);
  return readJson<any>(fp);
}

export function loadBlendBySlug(slug: string): any {
  const root = repoRoot();
  const fp = path.join(root, "content", "blends", `${slug}.json`);
  return readJson<any>(fp);
}

export function loadTopicBySlug(slug: string): any {
  const root = repoRoot();
  const fp = path.join(root, "content", "topics", "pages", `${slug}.json`);
  return readJson<any>(fp);
}

export function loadSafetyById(safetyId: string): any {
  const root = repoRoot();
  const fp = path.join(root, "content", "safety", `${safetyId}.json`);
  return readJson<any>(fp);
}

export function filterByQuery<T extends { name?: string; title?: string; slug: string }>(
  rows: T[],
  q: string | null | undefined
): T[] {
  const query = (q || "").trim().toLowerCase();
  if (!query) return rows;

  return rows.filter((r) => {
    const hay = `${r.slug} ${(r as any).name || ""} ${(r as any).title || ""}`.toLowerCase();
    return hay.includes(query);
  });
}
